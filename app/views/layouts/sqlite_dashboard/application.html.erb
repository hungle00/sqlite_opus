<!DOCTYPE html>
<html>
  <head>
    <title>SQLite Dashboard</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <%= csrf_meta_tags %>
    <%= csp_meta_tag %>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/dropzone@5/dist/min/dropzone.min.css" type="text/css" />
    <%= stylesheet_link_tag "application", "data-turbo-track": "reload" %>
    
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/theme/monokai.min.css">

    <!-- CodeMirror JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/sql/sql.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/edit/matchbrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/edit/closebrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/hint/show-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/hint/sql-hint.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/hint/show-hint.min.css">

    <script type="module">
      import { Application, Controller } from "https://unpkg.com/@hotwired/stimulus/dist/stimulus.js"

      // Query Executor Controller
      class QueryExecutorController extends Controller {
        static targets = ["queryInput", "queryName", "queryDescription", "saveError"]

        initialize() {
          this.currentPage = 1
          this.rowsPerPage = 25
          this.allData = null
        }

        connect() {
          // Initialize CodeMirror on the textarea
          if (this.hasQueryInputTarget && !this.editor) {
            this.editor = CodeMirror.fromTextArea(this.queryInputTarget, {
              mode: 'text/x-sql',
              theme: 'default',
              lineNumbers: true,
              matchBrackets: true,
              autoCloseBrackets: true,
              lineWrapping: true,
              extraKeys: {
                "Ctrl-Space": "autocomplete",
                "Cmd-Enter": () => this.executeQuery(),
                "Ctrl-Enter": () => this.executeQuery()
              }
            })

            // Set initial value
            this.editor.setValue(this.queryInputTarget.value || "SELECT * FROM sqlite_master WHERE type='table';")

            // Store editor reference globally for table selector
            window.sqlEditor = this.editor
          }
        }

        execute(event) {
          event.preventDefault()
          this.executeQuery()
        }

        executeQuery() {
          const form = this.element.querySelector('form') || this.element
          const query = this.editor ? this.editor.getValue() : this.queryInputTarget.value
          const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content

          // Create FormData and add the query
          const formData = new FormData()
          formData.append('query', query)

          fetch(form.action, {
            method: form.method || 'POST',
            body: formData,
            headers: {
              'X-CSRF-Token': csrfToken,
              'Accept': 'application/json'
            }
          })
          .then(response => response.json())
          .then(data => {
            console.log("Query response:", data)
            this.allData = data
            this.currentPage = 1
            this.displayResults()
          })
          .catch(error => {
            console.error("Query error:", error)
            this.displayError(error.message || "An error occurred")
          })
        }

        displayResults() {
          const resultsDiv = document.getElementById("query-results")

          if (!this.allData) return

          if (this.allData.error) {
            this.displayError(this.allData.error)
            return
          }

          if (this.allData.columns && this.allData.columns.length > 0) {
            const totalRows = this.allData.rows.length
            const totalPages = Math.ceil(totalRows / this.rowsPerPage)
            const startIndex = (this.currentPage - 1) * this.rowsPerPage
            const endIndex = Math.min(startIndex + this.rowsPerPage, totalRows)
            const pageRows = this.allData.rows.slice(startIndex, endIndex)

            let html = `
              <div class="export-controls">
                <div class="btn-group">
                  <button class="btn btn-sm btn-success" onclick="window.queryController.showExportModal('csv')">
                    <i class="fas fa-file-csv"></i> Export CSV
                  </button>
                  <button class="btn btn-sm btn-info" onclick="window.queryController.showExportModal('json')">
                    <i class="fas fa-file-code"></i> Export JSON
                  </button>
                </div>
              </div>
              <div class="pagination-controls">
                <div class="rows-per-page">
                  <label for="rows-per-page">Rows per page:</label>
                  <select id="rows-per-page" class="form-select form-select-sm" onchange="window.queryController.changeRowsPerPage(this.value)">
                    <option value="10" ${this.rowsPerPage == 10 ? 'selected' : ''}>10</option>
                    <option value="25" ${this.rowsPerPage == 25 ? 'selected' : ''}>25</option>
                    <option value="50" ${this.rowsPerPage == 50 ? 'selected' : ''}>50</option>
                    <option value="100" ${this.rowsPerPage == 100 ? 'selected' : ''}>100</option>
                    <option value="500" ${this.rowsPerPage == 500 ? 'selected' : ''}>500</option>
                  </select>
                </div>
                <div class="pagination-info">
                  Showing ${startIndex + 1} to ${endIndex} of ${totalRows} rows
                </div>
                <div class="pagination-buttons">
                  <button class="btn btn-sm btn-outline-secondary"
                          onclick="window.queryController.firstPage()"
                          ${this.currentPage === 1 ? 'disabled' : ''}>
                    <i class="fas fa-angle-double-left"></i>
                  </button>
                  <button class="btn btn-sm btn-outline-secondary"
                          onclick="window.queryController.previousPage()"
                          ${this.currentPage === 1 ? 'disabled' : ''}>
                    <i class="fas fa-angle-left"></i>
                  </button>
                  <span class="px-3">Page ${this.currentPage} of ${totalPages}</span>
                  <button class="btn btn-sm btn-outline-secondary"
                          onclick="window.queryController.nextPage()"
                          ${this.currentPage === totalPages ? 'disabled' : ''}>
                    <i class="fas fa-angle-right"></i>
                  </button>
                  <button class="btn btn-sm btn-outline-secondary"
                          onclick="window.queryController.lastPage()"
                          ${this.currentPage === totalPages ? 'disabled' : ''}>
                    <i class="fas fa-angle-double-right"></i>
                  </button>
                </div>
              </div>
              <div class="table-wrapper">
                <table class="table table-striped table-hover table-bordered table-sm">
                  <thead class="table-dark sticky-top">
                    <tr>
                      ${this.allData.columns.map(col => `<th>${this.escapeHtml(col)}</th>`).join('')}
                    </tr>
                  </thead>
                  <tbody>
                    ${pageRows.map(row =>
                      `<tr>${row.map(val => `<td>${this.escapeHtml(String(val || ''))}</td>`).join('')}</tr>`
                    ).join('')}
                  </tbody>
                </table>
              </div>
            `
            resultsDiv.innerHTML = html

            // Store reference for pagination controls
            window.queryController = this
          } else if (this.allData.message) {
            resultsDiv.innerHTML = `
              <div class="success-message">
                <i class="fas fa-check-circle"></i> ${this.escapeHtml(this.allData.message)}
              </div>
            `
          } else {
            resultsDiv.innerHTML = `
              <div class="text-muted text-center py-5">
                <p>No results returned</p>
              </div>
            `
          }
        }

        changeRowsPerPage(value) {
          this.rowsPerPage = parseInt(value)
          this.currentPage = 1
          this.displayResults()
        }

        firstPage() {
          this.currentPage = 1
          this.displayResults()
        }

        previousPage() {
          if (this.currentPage > 1) {
            this.currentPage--
            this.displayResults()
          }
        }

        nextPage() {
          const totalPages = Math.ceil(this.allData.rows.length / this.rowsPerPage)
          if (this.currentPage < totalPages) {
            this.currentPage++
            this.displayResults()
          }
        }

        lastPage() {
          this.currentPage = Math.ceil(this.allData.rows.length / this.rowsPerPage)
          this.displayResults()
        }

        displayError(error) {
          const resultsDiv = document.getElementById("query-results")
          resultsDiv.innerHTML = `
            <div class="error-message">
              <i class="fas fa-exclamation-circle"></i> <strong>Error:</strong> ${this.escapeHtml(error)}
            </div>
          `
        }

        escapeHtml(text) {
          const div = document.createElement('div')
          div.textContent = text
          return div.innerHTML
        }

        clear() {
          if (this.editor) {
            this.editor.setValue("")
            this.editor.focus()
          } else {
            this.queryInputTarget.value = ""
            this.queryInputTarget.focus()
          }
        }

        showExportModal(type = 'csv') {
          const existingModal = document.getElementById('export-modal')
          if (existingModal) {
            existingModal.remove()
          }

          let modalBody = ''
          let modalTitle = ''
          let downloadButton = ''

          if (type === 'csv') {
            modalTitle = 'Export to CSV'
            modalBody = `
              <div class="mb-3">
                <label for="csv-separator" class="form-label">Separator</label>
                <select id="csv-separator" class="form-select">
                  <option value=",">Comma (,)</option>
                  <option value=";">Semicolon (;)</option>
                  <option value="\t">Tab</option>
                  <option value="|">Pipe (|)</option>
                </select>
              </div>
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="csv-headers" checked>
                <label class="form-check-label" for="csv-headers">
                  Include headers as first row
                </label>
              </div>
            `
            downloadButton = `
              <button type="button" class="btn btn-success" onclick="window.queryController.exportCSV()">
                <i class="fas fa-download"></i> Download CSV
              </button>
            `
          } else if (type === 'json') {
            modalTitle = 'Export to JSON'
            modalBody = `
              <div class="mb-3">
                <label for="json-format" class="form-label">Format</label>
                <select id="json-format" class="form-select">
                  <option value="array">Array of Objects</option>
                  <option value="object">Object with Columns & Rows</option>
                </select>
                <small class="form-text text-muted">
                  Array: [{"col1": "val1"}, ...] | Object: {"columns": [...], "rows": [...]}
                </small>
              </div>
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="json-pretty" checked>
                <label class="form-check-label" for="json-pretty">
                  Pretty print (formatted with indentation)
                </label>
              </div>
            `
            downloadButton = `
              <button type="button" class="btn btn-info" onclick="window.queryController.exportJSON()">
                <i class="fas fa-download"></i> Download JSON
              </button>
            `
          }

          const modalHtml = `
            <div class="modal fade" id="export-modal" tabindex="-1">
              <div class="modal-dialog">
                <div class="modal-content">
                  <div class="modal-header">
                    <h5 class="modal-title">${modalTitle}</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                  </div>
                  <div class="modal-body">
                    ${modalBody}
                  </div>
                  <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    ${downloadButton}
                  </div>
                </div>
              </div>
            </div>
          `

          document.body.insertAdjacentHTML('beforeend', modalHtml)
          const modal = new bootstrap.Modal(document.getElementById('export-modal'))
          modal.show()
        }

        exportCSV() {
          const separator = document.getElementById('csv-separator').value
          const includeHeaders = document.getElementById('csv-headers').checked
          const query = this.editor ? this.editor.getValue() : this.queryInputTarget.value
          const form = this.element.querySelector('form') || this.element
          const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content

          const formData = new FormData()
          formData.append('query', query)
          formData.append('separator', separator)
          formData.append('include_headers', includeHeaders)

          fetch(form.action.replace('/execute_query', '/export_csv'), {
            method: 'POST',
            body: formData,
            headers: {
              'X-CSRF-Token': csrfToken
            }
          })
          .then(response => {
            if (!response.ok) {
              return response.json().then(err => { throw new Error(err.error || 'Export failed') })
            }
            return response.blob()
          })
          .then(blob => {
            const url = window.URL.createObjectURL(blob)
            const a = document.createElement('a')
            a.href = url
            a.download = `export_${new Date().getTime()}.csv`
            document.body.appendChild(a)
            a.click()
            window.URL.revokeObjectURL(url)
            a.remove()

            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('export-modal'))
            if (modal) modal.hide()
          })
          .catch(error => {
            alert('Export error: ' + error.message)
          })
        }

        exportJSON() {
          const format = document.getElementById('json-format').value
          const prettyPrint = document.getElementById('json-pretty').checked
          const query = this.editor ? this.editor.getValue() : this.queryInputTarget.value
          const form = this.element.querySelector('form') || this.element
          const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content

          const formData = new FormData()
          formData.append('query', query)
          formData.append('format', format)
          formData.append('pretty_print', prettyPrint)

          fetch(form.action.replace('/execute_query', '/export_json'), {
            method: 'POST',
            body: formData,
            headers: {
              'X-CSRF-Token': csrfToken
            }
          })
          .then(response => {
            if (!response.ok) {
              return response.json().then(err => { throw new Error(err.error || 'Export failed') })
            }
            return response.blob()
          })
          .then(blob => {
            const url = window.URL.createObjectURL(blob)
            const a = document.createElement('a')
            a.href = url
            a.download = `export_${new Date().getTime()}.json`
            document.body.appendChild(a)
            a.click()
            window.URL.revokeObjectURL(url)
            a.remove()

            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('export-modal'))
            if (modal) modal.hide()
          })
          .catch(error => {
            alert('Export error: ' + error.message)
          })
        }

        async saveQuery() {
          const name = this.queryNameTarget.value.trim()
          const description = this.queryDescriptionTarget.value.trim()
          const query = this.editor ? this.editor.getValue() : this.queryInputTarget.value
          const databaseName = this.element.dataset.databaseName

          if (!name) {
            this.showSaveError('Query name is required')
            return
          }

          if (!description) {
            this.showSaveError('Description is required')
            return
          }

          if (!query.trim()) {
            this.showSaveError('Query cannot be empty')
            return
          }

          try {
            const response = await fetch('/sqlite_dashboard/saved_queries', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content
              },
              body: JSON.stringify({
                saved_query: {
                  name: name,
                  description: description,
                  query: query,
                  database_name: databaseName
                }
              })
            })

            const data = await response.json()

            if (response.ok) {
              const modal = bootstrap.Modal.getInstance(document.getElementById('saveQueryModal'))
              modal.hide()
              this.queryNameTarget.value = ''
              this.queryDescriptionTarget.value = ''
              this.hideSaveError()
              alert('Query saved successfully!')
            } else {
              this.showSaveError(data.error || 'Failed to save query')
            }
          } catch (error) {
            console.error('Error saving query:', error)
            this.showSaveError(error.message)
          }
        }

        showSaveError(message) {
          if (this.hasSaveErrorTarget) {
            this.saveErrorTarget.textContent = message
            this.saveErrorTarget.classList.remove('d-none')
          }
        }

        hideSaveError() {
          if (this.hasSaveErrorTarget) {
            this.saveErrorTarget.classList.add('d-none')
          }
        }
      }

      // Table Selector Controller
      class TableSelectorController extends Controller {
        static targets = ["tableItem"]

        selectTable(event) {
          const tableName = event.currentTarget.dataset.tableName

          // Remove active class from all items
          this.tableItemTargets.forEach(item => {
            item.classList.remove("active")
          })

          // Add active class to clicked item
          event.currentTarget.classList.add("active")

          // Update query in CodeMirror editor
          if (window.sqlEditor) {
            window.sqlEditor.setValue(`SELECT * FROM ${tableName} LIMIT 100;`)
          } else {
            // Fallback to regular textarea
            const queryInput = document.getElementById("query")
            if (queryInput) {
              queryInput.value = `SELECT * FROM ${tableName} LIMIT 100;`
            }
          }

          // Trigger the query execution
          const form = document.querySelector('[data-controller="query-executor"]')
          if (form) {
            const submitButton = form.querySelector('button[type="submit"]')
            if (submitButton) {
              submitButton.click()
            } else {
              form.requestSubmit()
            }
          }
        }
      }

      // Saved Queries Controller
      class SavedQueriesController extends Controller {
        static targets = ["queryInput", "queryName", "queryDescription", "databaseSelector", "list", "saveError"]

        connect() {
          console.log("SavedQueries controller connected")
          this.loadSavedQueries()
          this.initializeCodeMirror()
        }

        initializeCodeMirror() {
          if (typeof CodeMirror !== 'undefined' && this.hasQueryInputTarget) {
            this.editor = CodeMirror.fromTextArea(this.queryInputTarget, {
              mode: 'text/x-sql',
              theme: 'default',
              lineNumbers: true,
              lineWrapping: true,
              autoCloseBrackets: true,
              matchBrackets: true,
              indentWithTabs: true,
              smartIndent: true,
              extraKeys: {
                "Ctrl-Enter": () => this.execute(),
                "Cmd-Enter": () => this.execute(),
                "Ctrl-Space": "autocomplete"
              }
            })
          }
        }

        async loadSavedQueries() {
          try {
            const response = await fetch('/sqlite_dashboard/saved_queries')
            const queries = await response.json()
            this.renderSavedQueries(queries)
          } catch (error) {
            console.error('Error loading saved queries:', error)
            if (this.hasListTarget) {
              this.listTarget.innerHTML = `<div class="text-danger small text-center py-3"><i class="fas fa-exclamation-triangle"></i> Error loading queries</div>`
            }
          }
        }

        renderSavedQueries(queries) {
          if (!this.hasListTarget) return

          if (queries.length === 0) {
            this.listTarget.innerHTML = `<div class="text-muted small text-center py-3">No saved queries</div>`
            return
          }

          const html = queries.map(query => `
            <div class="saved-query-item" data-query-id="${query.id}">
              <div class="d-flex justify-content-between align-items-start">
                <div class="flex-grow-1" style="cursor: pointer;"
                     data-action="click->saved-queries#loadQuery"
                     data-query-id="${query.id}"
                     data-query-name="${this.escapeHtml(query.name)}"
                     data-query-sql="${this.escapeHtml(query.query)}"
                     data-query-database="${query.database_name || ''}">
                  <div class="fw-bold small">${this.escapeHtml(query.name)}</div>
                  ${query.description ? `<div class="text-muted" style="font-size: 0.75rem;">${this.escapeHtml(query.description)}</div>` : ''}
                  ${query.database_name ? `<div class="text-info" style="font-size: 0.7rem;"><i class="fas fa-database"></i> ${this.escapeHtml(query.database_name)}</div>` : ''}
                </div>
                <button class="btn btn-sm btn-link text-danger p-0" data-action="click->saved-queries#deleteQuery" data-query-id="${query.id}">
                  <i class="fas fa-trash"></i>
                </button>
              </div>
            </div>
          `).join('')

          this.listTarget.innerHTML = html
        }

        escapeHtml(text) {
          const div = document.createElement('div')
          div.textContent = text
          return div.innerHTML
        }

        async execute() {
          const databaseId = this.databaseSelectorTarget.value
          if (!databaseId) {
            alert('Please select a database first')
            return
          }

          const query = this.editor ? this.editor.getValue() : this.queryInputTarget.value
          if (!query.trim()) {
            alert('Please enter a query')
            return
          }

          try {
            const response = await fetch(`/sqlite_dashboard/databases/${databaseId}/execute_query`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content
              },
              body: JSON.stringify({ query })
            })

            const data = await response.json()

            if (data.error) {
              this.renderError(data.error)
            } else {
              this.renderResults(data, query, databaseId)
            }
          } catch (error) {
            console.error('Error executing query:', error)
            this.renderError(error.message)
          }
        }

        renderResults(data) {
          const resultsContainer = document.getElementById('worksheet-results')

          if (data.message) {
            resultsContainer.innerHTML = `<div class="alert alert-success"><i class="fas fa-check-circle"></i> ${data.message}</div>`
            return
          }

          const { columns, rows } = data

          let html = `
            <div class="results-header">
              <h6>Query Results</h6>
              <div class="text-muted small">${rows.length} row(s) returned</div>
            </div>
            <div class="table-responsive">
              <table class="table table-striped table-hover">
                <thead><tr>${columns.map(col => `<th>${this.escapeHtml(col)}</th>`).join('')}</tr></thead>
                <tbody>
                  ${rows.map(row => `<tr>${row.map(cell => `<td>${cell !== null ? this.escapeHtml(String(cell)) : '<span class="text-muted">NULL</span>'}</td>`).join('')}</tr>`).join('')}
                </tbody>
              </table>
            </div>
          `

          resultsContainer.innerHTML = html
        }

        renderError(error) {
          const resultsContainer = document.getElementById('worksheet-results')
          resultsContainer.innerHTML = `<div class="alert alert-danger"><i class="fas fa-exclamation-circle"></i> <strong>Error:</strong> ${this.escapeHtml(error)}</div>`
        }

        clear() {
          if (this.editor) {
            this.editor.setValue('')
          } else {
            this.queryInputTarget.value = ''
          }
          document.getElementById('worksheet-results').innerHTML = `<div class="text-muted text-center py-5"><i class="fas fa-database fa-3x mb-3"></i><p>Select a database and execute a query to see results</p></div>`
        }

        async saveQuery() {
          const name = this.queryNameTarget.value.trim()
          const description = this.queryDescriptionTarget.value.trim()
          const query = this.editor ? this.editor.getValue() : this.queryInputTarget.value
          const databaseId = this.databaseSelectorTarget.value
          const databaseName = databaseId ? this.databaseSelectorTarget.options[this.databaseSelectorTarget.selectedIndex].text : null

          if (!name) {
            this.showSaveError('Query name is required')
            return
          }

          if (!description) {
            this.showSaveError('Description is required')
            return
          }

          if (!query.trim()) {
            this.showSaveError('Query cannot be empty')
            return
          }

          try {
            const response = await fetch('/sqlite_dashboard/saved_queries', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content
              },
              body: JSON.stringify({
                saved_query: { name, description, query, database_name: databaseName }
              })
            })

            const data = await response.json()

            if (response.ok) {
              const modal = bootstrap.Modal.getInstance(document.getElementById('saveQueryModal'))
              modal.hide()
              this.queryNameTarget.value = ''
              this.queryDescriptionTarget.value = ''
              this.hideSaveError()
              await this.loadSavedQueries()
              alert('Query saved successfully!')
            } else {
              this.showSaveError(data.error || 'Failed to save query')
            }
          } catch (error) {
            console.error('Error saving query:', error)
            this.showSaveError(error.message)
          }
        }

        showSaveError(message) {
          if (this.hasSaveErrorTarget) {
            this.saveErrorTarget.textContent = message
            this.saveErrorTarget.classList.remove('d-none')
          }
        }

        hideSaveError() {
          if (this.hasSaveErrorTarget) {
            this.saveErrorTarget.classList.add('d-none')
          }
        }

        loadQuery(event) {
          const element = event.currentTarget
          const queryName = element.dataset.queryName
          const querySql = element.dataset.querySql
          const queryDatabase = element.dataset.queryDatabase

          if (!confirm(`Load query "${queryName}" into the editor?`)) {
            return
          }

          if (this.editor) {
            this.editor.setValue(querySql)
          } else {
            this.queryInputTarget.value = querySql
          }

          if (queryDatabase && this.hasDatabaseSelectorTarget) {
            const option = Array.from(this.databaseSelectorTarget.options).find(opt => opt.text === queryDatabase)
            if (option) {
              this.databaseSelectorTarget.value = option.value
            }
          }
        }

        async deleteQuery(event) {
          event.stopPropagation()
          const queryId = event.currentTarget.dataset.queryId

          if (!confirm('Are you sure you want to delete this saved query?')) {
            return
          }

          try {
            const response = await fetch(`/sqlite_dashboard/saved_queries/${queryId}`, {
              method: 'DELETE',
              headers: { 'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content }
            })

            if (response.ok) {
              await this.loadSavedQueries()
            } else {
              const data = await response.json()
              alert(data.error || 'Failed to delete query')
            }
          } catch (error) {
            console.error('Error deleting query:', error)
            alert('Failed to delete query')
          }
        }

        refresh() {
          this.loadSavedQueries()
        }

        async exportCSV() {
          const databaseId = this.databaseSelectorTarget.value
          if (!databaseId) {
            alert('Please select a database first')
            return
          }

          const query = this.editor ? this.editor.getValue() : this.queryInputTarget.value
          if (!query.trim()) {
            alert('Please enter a query')
            return
          }

          const form = document.createElement('form')
          form.method = 'POST'
          form.action = `/sqlite_dashboard/databases/${databaseId}/export_csv`
          const csrfToken = document.querySelector('[name="csrf-token"]').content
          form.innerHTML = `
            <input type="hidden" name="authenticity_token" value="${csrfToken}">
            <input type="hidden" name="query" value="${this.escapeHtml(query)}">
            <input type="hidden" name="include_headers" value="true">
          `
          document.body.appendChild(form)
          form.submit()
          document.body.removeChild(form)
        }

        async exportJSON() {
          const databaseId = this.databaseSelectorTarget.value
          if (!databaseId) {
            alert('Please select a database first')
            return
          }

          const query = this.editor ? this.editor.getValue() : this.queryInputTarget.value
          if (!query.trim()) {
            alert('Please enter a query')
            return
          }

          const form = document.createElement('form')
          form.method = 'POST'
          form.action = `/sqlite_dashboard/databases/${databaseId}/export_json`
          const csrfToken = document.querySelector('[name="csrf-token"]').content
          form.innerHTML = `
            <input type="hidden" name="authenticity_token" value="${csrfToken}">
            <input type="hidden" name="query" value="${this.escapeHtml(query)}">
            <input type="hidden" name="format" value="array">
            <input type="hidden" name="pretty_print" value="true">
          `
          document.body.appendChild(form)
          form.submit()
          document.body.removeChild(form)
        }
      }

      // Initialize Stimulus
      window.Stimulus = Application.start()
      Stimulus.register("query-executor", QueryExecutorController)
      Stimulus.register("table-selector", TableSelectorController)
      Stimulus.register("saved-queries", SavedQueriesController)
    </script>
  </head>

  <body>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <div class="sqlite-dashboard-container">
      <%= yield %>
    </div>
  </body>
</html>